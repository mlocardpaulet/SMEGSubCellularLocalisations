---
title: "Proteomic analysis SMEG"
author: "Marie Locard-Paulet"
date: '`r date()`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
```

```{r, message=F}
require(ggplot2)
require(knitr)

#source("https://bioconductor.org/biocLite.R")
#biocLite(c("MSnbase", "pRoloc", "pRolocdata", "pRolocGUI"))
require(MSnbase)
require(pRoloc)
```

I load the data before stat (technical repeats aggregated and missing values replaced).

```{r}
load("Data/Data03.Rdata")
```

I remove the rows with only missing values in the quan.

```{r}
mat <- as.matrix(export[,527:542])
naval <- sapply(seq_len(nrow(mat)), function(x) {
  length(mat[x,][is.na(mat[x,])])
})
export <- export[naval == 0,]
```

# With our imputation of missing values:

I create 4 independent MSnet objects to normalise the biological repeats independently.

```{r}
# The order of the columns is important when creating the MSnet object:
coln1 <- c(1,5,9,13)+526
coln2 <- coln1+1
coln3 <- coln1+2
coln4 <- coln1+3

coln <- c(coln1, coln2, coln3, coln4)
# The name of the columns has to be the condition . the replicate:
names(export)[coln] <- gsub("[1234]_woMissingVal", "", names(export)[coln])
names(export)[coln] <- paste0(names(export)[coln], ".", rep(c(1,2,3,4), each = 4))

hl1 <- readMSnSet2(export, ecol = coln1, fnames = 1)
head(exprs(hl1))
hl2 <- readMSnSet2(export, ecol = coln2, fnames = 1)
head(exprs(hl2))
hl3 <- readMSnSet2(export, ecol = coln3, fnames = 1)
head(exprs(hl3))
hl4 <- readMSnSet2(export, ecol = coln4, fnames = 1)
head(exprs(hl4))

# Normalisation:
hl1 <- normalise(hl1, method = "sum")
hl2 <- normalise(hl2, method = "sum")
hl3 <- normalise(hl3, method = "sum")
hl4 <- normalise(hl4, method = "sum")
```

After normalisation, I combine the data:

```{r}
# Combine the data:
hl <- combine(hl1, hl2, hl3, hl4)
```

I annotate the data:

```{r}
# Annotate the data:
#fvarLabels(hl)
tab <- read.table("RAW/Quantified proteins 290917_Mapping.txt", sep = "\t", header = T)
tab[,1] <- gsub("_[123456]", "_woMissingVal", tab[,1])
tab <- tab[,-4]
tab <- tab[!duplicated(tab),]
names(tab)[3] <- "Replicate"
names(tab)[2] <- "Gradient.Fraction"
tab <- tab[order(tab$Replicate),]
tab$Sample.name <- gsub("[1234]_woMissingVal", "", tab$Sample.name)
tab$Sample.name <- paste0(tab$Sample.name, ".", rep(c(1,2,3,4), each = 4))
row.names(tab) <- tab$Sample.name # This is essential.
tab <- tab[,c(3,1,2)]
pData(hl) <- tab
```

I have already imputed the missing data so I don't do it again. I may want to try with data before replacement of missing data and use the MSbase algo.

```{r}
par(mfrow = c(1, 2), ## creates a two-panel figure
    las = 2, ## axis labels orientation
    cex.axis = .7) ## axis label size
o <- order(hl$Sample.name)
plotDist(hl[, o], pcol = "#00000010", xlab = "")
lines(colMeans(exprs(hl[, o])), col = "red", type = "b")
boxplot(exprs(hl[, o]))

plot2D(hl, fcol = NULL, col = "black")
plot2D(hl, method = "hexbin")
```

The "lines" observed in the PCA may be due to the replacement of missing values (I didn't introduce variability when imputing it).

================================================================================

# With imputation of missing values using knn algo.:


I create 4 independent MSnet objects to normalise the biological repeats independently.

```{r}
# The order of the columns is important when creating the MSnet object:
coln1 <- c(1,5,9,13)+494
coln2 <- coln1+1
coln3 <- coln1+2
coln4 <- coln1+3

coln <- c(coln1, coln2, coln3, coln4)
# The name of the columns has to be the condition . the replicate:
names(export)[coln] <- gsub("[1234]_MeanTech", "", names(export)[coln])
names(export)[coln] <- paste0(names(export)[coln], ".", rep(c(1,2,3,4), each = 4))

hl1 <- readMSnSet2(export, ecol = coln1, fnames = 1)
head(exprs(hl1))
hl2 <- readMSnSet2(export, ecol = coln2, fnames = 1)
head(exprs(hl2))
hl3 <- readMSnSet2(export, ecol = coln3, fnames = 1)
head(exprs(hl3))
hl4 <- readMSnSet2(export, ecol = coln4, fnames = 1)
head(exprs(hl4))

# Normalisation:
#hl1 <- normalise(hl1, method = "sum")
#hl2 <- normalise(hl2, method = "sum")
#hl3 <- normalise(hl3, method = "sum")
#hl4 <- normalise(hl4, method = "sum")
```

Imputation of missing values:

```{r}
lhl <- list(hl1, hl2, hl3, hl4)

matCV <- export[,grepl("CVTech", names(export))]
medCV <- sapply(seq_len(ncol(matCV)), function(x) {
  median(matCV[,x], na.rm = T)
})
medCV <- medCV[c(c(1,5,9,13), c(1,5,9,13)+1, c(1,5,9,13)+2, c(1,5,9,13)+3)]

for (i in seq_along(lhl)) {
   l <- as.matrix(exprs(lhl[[i]]))
  # l <- lhl[[i]]
  image2(l, main = paste0("Replicate ", i, " before normalisation"))
  # l <- impute(l, method = "QRILC")

  # Impute missing value:
   #vec <- sapply(seq_len(ncol(l)), function(x) {
  #   quantile(l[,x][!is.na(l[,x])], probs = 0.05) # Replace around 5% quantile
  # })
  val <- quantile(l[!is.na(l)], probs = 0.01) # Replace around 1% quantile
  # for (j in seq_len(ncol(l))) {
  #   vec2 <- l[,j]
  #   vrep <- runif(length(l[,j][is.na(l[,j])]),(vec[j]-(medCV[j]*vec[j])),vec[j]+(medCV[j]*vec[j]))
     vrep <- runif(length(l),(val-(mean(medCV)*val)),val+(mean(medCV)*val))
  #   vec2[is.na(vec2)] <- vrep
     l[is.na(l)] <- vrep[is.na(l)]
   #}
   exprs(lhl[[i]]) <- l
   l <- lhl[[i]]
    # Normalisation:
  l <- normalise(l, method = "sum")
  image2(l, 
        main = paste0("Replicate ", i, ": Values after normalisation and imputation of missing values"))
  plot2D(l, fcol = NULL, col = "black")
  plot2D(l, method = "hexbin")
  lhl[[i]] <- l
}
```

Combination of the data:

```{r}
# Combine the data:
hl <- combine(lhl[[1]], lhl[[2]], lhl[[3]], lhl[[4]])
```


I annotate the data:

```{r}
# Annotate the data:
#fvarLabels(hl)
tab <- read.table("RAW/Quantified proteins 290917_Mapping.txt", sep = "\t", header = T)
tab[,1] <- gsub("_[123456]", "_MeanTech", tab[,1])
tab <- tab[,-4]
tab <- tab[!duplicated(tab),]
names(tab)[3] <- "Replicate"
names(tab)[2] <- "Gradient.Fraction"
tab <- tab[order(tab$Replicate),]
tab$Sample.name <- gsub("[1234]_MeanTech", "", tab$Sample.name)
tab$Sample.name <- paste0(tab$Sample.name, ".", rep(c(1,2,3,4), each = 4))
row.names(tab) <- tab$Sample.name # This is essential.
tab <- tab[,c(3,1,2)]
pData(hl) <- tab
```

```{r}
par(mfrow = c(1, 2), ## creates a two-panel figure
    las = 2, ## axis labels orientation
    cex.axis = .7) ## axis label size
o <- order(hl$Sample.name)
plotDist(hl[, o], pcol = "#00000010", xlab = "")
lines(colMeans(exprs(hl[, o])), col = "red", type = "b")
boxplot(exprs(hl[, o]))

plot2D(hl, fcol = NULL, col = "black")
plot2D(hl, method = "hexbin")
```

## Add markers

I use the table

```{r}
markertab <- read.table("LOPIT/Copie de protéines marqueurs LOPIT.txt", header = T, stringsAsFactors = F, sep = "\t")
markers <- markertab$localisation
names(markers) <- markertab$accession

hl <- addMarkers(hl, markers)
par(mfrow = c(1, 2))
plot2D(hl, main = "pRolocmarkers for mouse")
addLegend(hl, cex = .6)
plot2D(hl, dims = c(1, 3), main = "Marker resolution along PC 1 and 7")
#plot3D(hl)

par(xpd=TRUE, mar = c(4,4,4,16), mfrow = c(1,1))
hlo <- hl[, order(hl$Sample.name)]
col <- c("blueviolet", "darkblue", "aquamarine2", "darkgreen")
plotDist(hlo[fData(hlo)$markers == unique(markers)[1],], pcol = col[1], fractions = "Sample.name")
title(main = "Marker occupancy profiles along the gradient")
for (i in 1:length(unique(markers))) {
  matlines(t(exprs(hlo[fData(hlo)$markers == unique(markers)[i], ])), lty = 1, col = col[i], type = "l")
}
legend(17, 0.3, unique(markers), lty = 1, col = col, bty = "n")
```


```{r}
sessionInfo()
```
